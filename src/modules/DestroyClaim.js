const _ = require("lodash");

const DestroyClaimValidator = require("./DestroyClaimValidator");
const {
  DestroyClaimValidationError,
  DestroyClaimError,
} = require("../util/errors");

const DestroyContactExtension = require("./DestroyContactExtension");
const DestroySubjectExtension = require("./DestroySubjectExtension");
const DestroyConditionExtension = require("./DestroyConditionExtension");
const DestroyActionExtension = require("./DestroyActionExtension");

const {
  buildReferencesList,
  evaluateConditionsField,
  isSimulationMode,
  isExpired,
  deepFreeze,
} = require("../util/dcTools");

/**
 * Destroy Claim Class
 */
class DestroyClaim {
  #destroyclaimOriginal;

  #support;

  #destroyclaim;

  #destroySubjects;

  #destroyContacts;

  #destroyConditions;

  #destroyActions;

  #evaluation;

  #state = {};

  /**
   * Create a DestroyClaim Instance
   * @param {Object} destroyclaim
   * @param {Object} support support object (can be generated by SupportObjectGenerator)
   * @throws {TypeError} throws when parameter types not correct
   */
  constructor(destroyclaim, support) {
    if (!_.isObject(destroyclaim)) {
      throw new TypeError(
        "DestroyClaim: parameter destroyclaim must be of type Object."
      );
    }
    if (!_.isObject(support)) {
      throw new TypeError(
        "DestroyClaim: parameter support must be of type Object."
      );
    }
    this.#destroyclaimOriginal = deepFreeze(_.cloneDeep(destroyclaim)); // make a immutable copy of the destroy claim.
    this.#destroyclaim = _.cloneDeep(destroyclaim); // make a deep copy to work on
    this.#support = deepFreeze(_.cloneDeep(support)); // needed to prevent any unwanted changes on the support

    this.#destroySubjects = [];
    this.#destroyContacts = [];
    this.#destroyConditions = [];
    this.#destroyActions = [];

    // init functions
    this.#evaluation = buildReferencesList(this.#destroyclaimOriginal).reduce(
      (acc, value) => ({
        ...acc,
        [value]: {
          evaluation: null,
          conditions: null,
        },
      }),
      {}
    );
    this.#setDefaultConditions();
    this.#validateDestroyClaim();
    this.#generateExtensions();
  }

  #validateDestroyClaim() {
    const Validator = new DestroyClaimValidator(
      this.#destroyclaim,
      this.#support
    );
    if (!Validator.validateDestroyClaim()) {
      throw new DestroyClaimValidationError(
        "DestroyClaim: destroy claim validation failed.",
        Validator.getValidationErrors()
      );
    }
    this.#evaluation[this.#destroyclaimOriginal.id].evaluation = true;
  }

  #setDefaultConditions() {
    const extensionFields = [
      "destroySubjects",
      "destroyContacts",
      "destroyConditions",
      "destroyActions",
    ];

    // eslint-disable-next-line no-restricted-syntax
    for (const field of extensionFields) {
      if (field in this.#destroyclaimOriginal) {
        this.#destroyclaim[field].forEach((elem) => {
          // eslint-disable-next-line no-param-reassign
          elem.conditions = "conditions" in elem ? elem.conditions : true;
        });
      }
    }
    // default root conditions is a locial and over all destroySubjects
    this.#destroyclaim.conditions =
      "conditions" in this.#destroyclaimOriginal
        ? this.#destroyclaimOriginal.conditions
        : {
            and: [
              ...buildReferencesList(
                this.#destroyclaimOriginal,
                "destroySubjects"
              ).map((id) => ({ var: id })),
            ],
          };
  }

  #generateExtensions() {
    this.#destroyclaim.destroySubjects.forEach((subject) => {
      this.#destroySubjects.push(
        new DestroySubjectExtension(
          subject,
          this.#support.extensions[subject.name].schema,
          this.#support.extensions[subject.name].evaluation,
          this.#support.extensions[subject.name].process
        )
      );
    });
    if ("destroyContacts" in this.#destroyclaim) {
      this.#destroyclaim.destroyContacts.forEach((contact) => {
        this.#destroyContacts.push(
          new DestroyContactExtension(
            contact,
            this.#support.extensions[contact.name].schema,
            this.#support.extensions[contact.name].evaluation
          )
        );
      });
    }
    if ("destroyConditions" in this.#destroyclaim) {
      this.#destroyclaim.destroyConditions.forEach((condition) => {
        this.#destroyConditions.push(
          new DestroyConditionExtension(
            condition,
            this.#support.extensions[condition.name].schema,
            this.#support.extensions[condition.name].evaluation
          )
        );
      });
    }
    if ("destroyActions" in this.#destroyclaim) {
      this.#destroyclaim.destroyActions.forEach((action) => {
        this.#destroyActions.push(
          new DestroyActionExtension(
            action,
            this.#support.extensions[action.name].schema,
            this.#support.extensions[action.name].evaluation,
            this.#support.extensions[action.name].process
          )
        );
      });
    }
  }

  async #evaluateDestroySubjects() {
    const evaluateSubjects = this.#destroySubjects.map(async (subject) => ({
      id: subject.getId(),
      evaluation:
        (await subject.evaluate()) &&
        subject.getName() in this.#support.extensions, // second check is for normal mode, need to check if extension is supported
    }));

    return Promise.allSettled(evaluateSubjects).then((results) =>
      results.forEach((r) => {
        if (r.status === "rejected") {
          throw new Error(r.reason);
        }
        this.#evaluation[r.value.id].evaluation = _.isBoolean(
          r.value.evaluation
        )
          ? r.value.evaluation
          : false;
      })
    );
  }

  async #evaluateDestroyContacts() {
    const evaluateContacts = this.#destroyContacts.map(async (contact) => ({
      id: contact.getId(),
      evaluation:
        (await contact.evaluate()) &&
        contact.getName() in this.#support.extensions,
    }));

    return Promise.allSettled(evaluateContacts).then((results) =>
      results.forEach((r) => {
        if (r.status === "rejected") {
          throw new Error(r.reason);
        }
        this.#evaluation[r.value.id].evaluation = _.isBoolean(
          r.value.evaluation
        )
          ? r.value.evaluation
          : false;
      })
    );
  }

  async #evaluateDestroyConditions() {
    const evaluateConditions = this.#destroyConditions.map(
      async (condition) => ({
        id: condition.getId(),
        evaluation:
          (await condition.evaluate()) &&
          condition.getName() in this.#support.extensions,
      })
    );

    return Promise.allSettled(evaluateConditions).then((results) =>
      results.forEach((r) => {
        if (r.status === "rejected") {
          throw new Error(r.reason);
        }
        this.#evaluation[r.value.id].evaluation = _.isBoolean(
          r.value.evaluation
        )
          ? r.value.evaluation
          : false;
      })
    );
  }

  async #evaluateDestroyActions() {
    const evaluateActions = this.#destroyActions.map(async (action) => ({
      id: action.getId(),
      evaluation:
        (await action.evaluate()) &&
        action.getName() in this.#support.extensions,
    }));

    return Promise.allSettled(evaluateActions).then((results) =>
      results.forEach((r) => {
        if (r.status === "rejected") {
          throw new Error(r.reason);
        }
        this.#evaluation[r.value.id].evaluation = _.isBoolean(
          r.value.evaluation
        )
          ? r.value.evaluation
          : false;
      })
    );
  }

  async #evaluateBasic() {
    return Promise.all([
      this.#evaluateDestroySubjects(),
      this.#evaluateDestroyContacts(),
      this.#evaluateDestroyConditions(),
      this.#evaluateDestroyActions(),
    ]);
  }

  #unevaluatedConditionsLeft() {
    // eslint-disable-next-line no-restricted-syntax
    for (const value of Object.values(this.#evaluation)) {
      if (_.isNull(value.conditions)) {
        return true;
      }
    }
    return false;
  }

  #evaluateConditionsInner(id, conditions) {
    const data = Object.fromEntries(
      Object.entries(this.#evaluation).map(([k, v]) => {
        if (_.isNull(v.conditions)) {
          return [k, null];
        }
        return [k, v.evaluation && v.conditions];
      })
    );

    const conditionsEvaluation = evaluateConditionsField(conditions, data);

    if (!_.isNull(conditionsEvaluation) && _.isBoolean(conditionsEvaluation)) {
      this.#evaluation[id].conditions = conditionsEvaluation;
    }
  }

  async #evaluateConditions() {
    // iterate over all conditions over and over till finished (not null)
    const extensions = [
      ...this.#destroySubjects,
      ...this.#destroyContacts,
      ...this.#destroyConditions,
      ...this.#destroyActions,
    ];

    while (this.#unevaluatedConditionsLeft()) {
      extensions.forEach((e) => {
        this.#evaluateConditionsInner(e.getId(), e.getConditions());
      });
      this.#evaluateConditionsInner(
        this.#destroyclaim.id,
        this.#destroyclaim.conditions
      );
    }
  }

  // Getter Functions

  /**
   * Get original destroy claim JSON
   * @returns {Object} returns original destroy claim JSON (frozen)
   */
  getDestroyClaimJSON() {
    return this.#destroyclaimOriginal; // already frozen in constructor
  }

  /**
   * Get the destroyReasons field of the destroy claim
   * @returns {(Array.<String>|undefined)} returns the list of destroy reasons
   */
  getDestroyReasons() {
    return this.#destroyclaimOriginal.destroyReasons;
  }

  /**
   * Get the DestroySubjectExtension of the destroy claim.
   * This not the plain destroySubjects JSON field, but the Extension class representation.
   * @returns {Array.<DestroySubjectExtension>} returns a list of DestroySubjectExtension
   */
  getDestroySubjects() {
    return this.#destroySubjects;
  }

  /**
   * Get the DestroyContactExtension of the destroy claim.
   * This not the plain destroyContacts JSON field, but the Extension class representation.
   * @returns {Array.<DestroyContactExtension>} returns a list of DestroyContactExtension
   */
  getDestroyContacts() {
    return this.#destroyContacts;
  }

  /**
   * Get the DestroyConditionExtension of the destroy claim.
   * This not the plain destroyConditions JSON field, but the Extension class representation.
   * @returns {Array.<DestroyConditionExtension>} returns a list of DestroyConditionExtension
   */
  getDestroyConditions() {
    return this.#destroyConditions;
  }

  /**
   * Get the DestroyActionExtension of the destroy claim.
   * This not the plain destroyActions JSON field, but the Extension class representation.
   * @returns {Array.<DestroyActionExtension>} returns a list of DestroyActionExtension
   */
  getDestroyActions() {
    return this.#destroyActions;
  }

  /**
   * Get evaluation state.
   * Can be used to explain why a destroy claim may not be executed.
   * @returns {Object} returns the evaluation object
   */
  getEvaluationState() {
    return deepFreeze(_.cloneDeep(this.#evaluation));
  }

  /**
   * Get the id field of the destroy claim
   * @returns {String} returns id
   */
  getId() {
    return this.#destroyclaimOriginal.id; // exists always
  }

  /**
   * Get the isActive field of the destroy claim
   * @returns {Boolean} returns isActive
   */
  getIsActive() {
    return this.#destroyclaimOriginal.isActive; // exists always
  }

  /**
   * Get the strictMode field of the destroy claim
   * @returns {(Boolean|undefined)} returns strictMode
   */
  getStrictMode() {
    return this.#destroyclaimOriginal.strictMode;
  }

  /**
   * Get the simulationMode field of the destroy claim
   * @returns {(Boolean|undefined)} returns simulationMode
   */
  getSimulationMode() {
    return this.#destroyclaimOriginal.simulationMode;
  }

  /**
   * Get the manualMode field of the destroy claim
   * @returns {(Boolean|undefined)} returns manualMode
   */
  getManualMode() {
    return this.#destroyclaimOriginal.manualMode;
  }

  /**
   * Get the notificationMode field of the destroy claim
   * @returns {(Boolean|undefined)} returns notificationMode
   */
  getNotificationMode() {
    return this.#destroyclaimOriginal.notificationMode;
  }

  /**
   * Get the expirationDate field of the destroy claim
   * @returns {(String|undefined)} returns expirationDate
   */
  getExpirationDate() {
    return this.#destroyclaimOriginal.expirationDate;
  }

  /**
   * Get the title field of the destroy claim
   * @returns {(String|undefined)} returns title
   */
  getTitle() {
    return this.#destroyclaimOriginal.title;
  }

  /**
   * Get the description field of the destroy claim
   * @returns {(String|undefined)} returns description
   */
  getDescription() {
    return this.#destroyclaimOriginal.description;
  }

  /**
   * Get the keywords field of the destroy claim
   * @returns {(Array.<String>|undefined)} returns keywords
   */
  getKeywords() {
    return this.#destroyclaimOriginal.keywords;
  }

  /**
   * Get the issued field of the destroy claim
   * @returns {(String|undefined)} returns issued
   */
  getIssued() {
    return this.#destroyclaimOriginal.issued;
  }

  /**
   * Get the modified field of the destroy claim
   * @returns {(String|undefined)} returns modified
   */
  getModified() {
    return this.#destroyclaimOriginal.modified;
  }

  /**
   * Get the modelVersion field of the destroy claim
   * @returns {(String|undefined)} returns modelVersion
   */
  getModelVersion() {
    return this.#destroyclaimOriginal.modelVersion;
  }

  /**
   * Get the signature field of the destroy claim
   * @returns {(String|undefined)} returns signature
   */
  getSignature() {
    return this.#destroyclaimOriginal.signature;
  }

  /**
   * Get the conditions field of the destroy claim
   * @returns {(Boolean|Object|undefined)} returns conditions
   */
  getConditions() {
    return this.#destroyclaimOriginal.conditions;
  }

  /**
   * Checks if the destroy claim is executable.
   * Evaluation must have already been performed.
   * @returns {Boolean} returns if destroy claim is executable
   */
  isExecutable() {
    if (
      this.#evaluation[this.#destroyclaimOriginal.id].evaluation &&
      this.#evaluation[this.#destroyclaimOriginal.id].conditions
    ) {
      return true;
    }
    return false;
  }

  /**
   * Returns the state of the instanciation
   * @param {String} key key to receive from
   * @returns {*} returns state
   * @throws {TypeError} throws if parameter not set or wronmg type
   */
  getState(key) {
    if (_.isUndefined(key) || !_.isString(key)) {
      throw new TypeError(
        "DestroyClaim: key parameter must be set and of type String."
      );
    }
    return this.#state[key];
  }

  /**
   * Set a value by key in the state object of the instanciation
   * @param {String} key key where to store the value
   * @param {*} value value that will be stored
   * @throws {TypeError} throws, if parameter not set or wrong type
   */
  setState(key, value) {
    if (_.isUndefined(key) || !_.isString(key)) {
      throw new TypeError(
        "DestroyClaim: key parameter must be set and of type String."
      );
    }
    if (_.isUndefined(value)) {
      throw new TypeError("DestroyClaim: value parameter must be set.");
    }
    this.#state[key] = value;
  }

  /**
   * evaluate destroy claim
   * @throws {*} throws when there is an error on evaluation. DCA can inject own code, so throw type may vary.
   */
  async evaluate() {
    await this.#support.preAllEvaluationHook(this);
    await this.#evaluateBasic();
    await this.#evaluateConditions();
    await this.#support.postAllEvaluationHook(this);
  }

  /**
   * Executes the destroy claim.
   * Evaluation must have already been performed.
   * @throws {*} throws if soe
   */
  async execute() {
    await this.#support.preAllExecuteHook(this);

    if (!this.isExecutable()) {
      throw new DestroyClaimError(
        "DestroyClaim: destroy claim execution conditions are not met yet."
      );
    }
    if (!this.#destroyclaimOriginal.isActive) {
      throw new DestroyClaimError("DestroyClaim: destroy claim is not active");
    }
    if (isExpired(this.#destroyclaimOriginal)) {
      throw new DestroyClaimError("DestroyClaim: destroy claim is expired");
    }

    const processPromises = this.#destroySubjects.map((subject) => {
      if (
        this.#evaluation[subject.getId()].evaluation &&
        this.#evaluation[subject.getId()].conditions
      ) {
        if (_.isNull(subject.getAction())) {
          if (!isSimulationMode(this.#destroyclaimOriginal)) {
            return subject.processRealMode();
          }
          return subject.processSimulationMode();
        }
        const action = this.#destroyActions.find(
          (o) => o.getId() === subject.getAction()
        );
        if (!isSimulationMode(this.#destroyclaimOriginal)) {
          return action.processRealMode(subject);
        }
        return action.processSimulationMode(subject);
      }
      return Promise.resolve(true);
    });

    await Promise.all(processPromises);
    await this.#support.postAllExecuteHook(this);
  }

  /**
   * start processing the destroy claim
   */
  async process() {
    await this.evaluate();
    await this.execute();
  }
}

module.exports = DestroyClaim;
